use std::fmt::Display;
use std::fs::File;
use std::io::{Error, ErrorKind, Result, Write};
use std::path::Path;

///
/// JSON serializer with eXtra Small memory footprint.
/// Very immature, experimental code.
/// The main idea is that application data structure is NOT duplicated into another one, just for the purpose of saving JSON.
/// Instead, JSON is generated by calls to this api, and client is responsible for making calls in proper sequence. JsonFx only helps with basic stuff like tokenization.
///
/// TODO: add automatic scope closing (and make it the only way to close level)
///
pub struct JsonXsSerializer<'a> {
    writer: Box<dyn Write + 'a>,
    levels: Vec<Level>,
}

struct Level {
    /// number of completed elements
    size: usize,
    /// collection type
    ctype: CollectionType,
}

enum CollectionType {
    JsonArray,
    JsonObject {
        /// the key under construction, if value is collection
        key: JsonXsValue
    },
}

#[derive(Clone)]
pub enum JsonXsValue/*<'a>*/ {
    Null,
    Bool(bool),
    Int(i64),
    Unsigned(u64),
    Decimal(f64),
    String(String),
    // TODO/nice: Str(&'a str),

    /// only for use in `key` param - to indicate array element, not object
    NA,
}

impl Display for JsonXsValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            JsonXsValue::NA => Ok(()),
            JsonXsValue::Null => write!(f, "null"),
            JsonXsValue::Bool(value) => write!(f, "{}", value),
            JsonXsValue::Int(value) => write!(f, "{}", value),
            JsonXsValue::Unsigned(value) => write!(f, "{}", value),
            JsonXsValue::Decimal(value) => write!(f, "{}", value),
            JsonXsValue::String(value) => write!(f, "\"{}\"", value
                .replace("\\", "\\\\")
                .replace("\n", "\\n")
                .replace("\"", "\\\"")), // TODO this escaping is insufficient
        }
    }
}

impl JsonXsSerializer<'_> {
    pub fn use_stdout() -> Self {
        let writer = Box::new(std::io::stdout());
        JsonXsSerializer { writer, levels: vec![] }
    }

    pub fn use_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let writer = Box::new(File::create(path)?);
        Ok(JsonXsSerializer { writer, levels: vec![] })
    }

    pub fn done(&mut self) -> Result<()> {
        self.writer.flush()?;
        if !self.levels.is_empty() {
            return Err(Error::new(ErrorKind::InvalidData, "Not empty!"));
        }
        Ok(())
    }

    pub fn open_obj<K: Into<JsonXsValue>+Clone>(&mut self, key: K) -> Result<()> {
        self.val_start()?;
        self.obj_key(key.clone())?;
        self.writer.write(b"{")?;
        self.levels.push(Level {
            size: 0,
            ctype: CollectionType::JsonObject { key: key.into() },
        });
        Ok(())
    }

    pub fn open_array<K: Into<JsonXsValue>>(&mut self, key: K) -> Result<()> {
        self.val_start()?;
        self.obj_key(key)?;
        self.writer.write(b"[")?;
        self.levels.push(Level {
            size: 0,
            ctype: CollectionType::JsonArray,
        });
        Ok(())
    }

    pub fn close(&mut self) -> Result<()> {
        match self.levels.pop() {
            None => Err(Error::new(ErrorKind::InvalidData, "no collection to close")),
            Some(level) => {
                match level.ctype {
                    CollectionType::JsonArray => {
                        self.writer.write(b"]")
                    }
                    CollectionType::JsonObject { key:_ } => {
                        self.writer.write(b"}")
                    }
                }
            }
        }?;
        self.val_end()
    }

    /// extremely minimalistic indentation
    fn indent(&mut self) -> Result<()> {
        self.writer.write(b"\n")?;
        for _ in &self.levels {
            self.writer.write(b"\t")?;
        }
        Ok(())
    }

    fn val_start(&mut self) -> Result<()> {
        let elem_separator =
            match self.levels.last() {
                Some(top) => top.size > 0,
                None => false
            };
        if elem_separator {
            self.writer.write(b",")?;
        }
        self.indent()?;
        Ok(())
    }

    fn val_end(&mut self) -> Result<()> {
        match self.levels.last_mut() {
            Some(top) => top.size += 1,
            None => {}
        }
        Ok(())
    }

    fn obj_key<K: Into<JsonXsValue>>(&mut self, key: K) -> Result<()> {
        let ki = key.into();
        let key_str = &ki.to_string();
        match ki.clone() {
            JsonXsValue::NA => {
                match self.levels.last() {
                    None => {},
                    Some(level) => match &level.ctype {
                        CollectionType::JsonArray => {},
                        CollectionType::JsonObject { .. } => Err(Error::new(ErrorKind::InvalidData, "object element must have key"))?
                    },
                }
            },
            _ => {
                match self.levels.last_mut() {
                    None => Err(Error::new(ErrorKind::InvalidData, "top-level element cannot have key"))?,
                    Some(level) => match &mut level.ctype {
                        CollectionType::JsonArray => Err(Error::new(ErrorKind::InvalidData, "array element cannot have key"))?,
                        CollectionType::JsonObject { key } => *key = ki, // TODO: use for tracking, in close
                    },
                }
                self.writer.write(key_str.as_bytes())?;
                self.writer.write(b":")?;
            },
        }
        Ok(())
    }

    pub fn element<K: Into<JsonXsValue>,V: Into<JsonXsValue>> (&mut self, key: K, value: V) -> Result<()> {
        self.val_start()?;
        self.obj_key(key)?;
        let v = value.into();
        self.writer.write(v.to_string().as_bytes())?;
        self.val_end()
    }
}

impl Into<JsonXsValue> for String {
    fn into(self) -> JsonXsValue { JsonXsValue::String(self.to_string()) }
}

impl Into<JsonXsValue> for &String {
    fn into(self) -> JsonXsValue { JsonXsValue::String(self.to_string()) }
}
impl Into<JsonXsValue> for &str {
    fn into(self) -> JsonXsValue { JsonXsValue::String(self.to_string()) }
}
impl Into<JsonXsValue> for usize {
    fn into(self) -> JsonXsValue { JsonXsValue::Unsigned(self as u64) }
}
impl Into<JsonXsValue> for &i32 {
    fn into(self) -> JsonXsValue { JsonXsValue::Int(*self as i64) }
}
impl Into<JsonXsValue> for &i64 {
    fn into(self) -> JsonXsValue { JsonXsValue::Int(*self) }
}
impl Into<JsonXsValue> for &f32 {
    fn into(self) -> JsonXsValue { JsonXsValue::Decimal(*self as f64) }
}
impl Into<JsonXsValue> for &f64 {
    fn into(self) -> JsonXsValue { JsonXsValue::Decimal(*self) }
}

#[cfg(test)]
mod tests {
    use std::io::{Result, Write};

    use crate::jsonxs::JsonXsValue;

    use super::JsonXsSerializer;

    struct MyBuf {
        bytes: Vec<u8>,
    }

    impl MyBuf {
        fn collected_output(&self) -> String {
            std::str::from_utf8(self.bytes.as_slice()).unwrap().to_string()
        }
    }

    impl Write for MyBuf {
        fn write(&mut self, buf: &[u8]) -> Result<usize> {
            self.bytes.write(buf)
        }

        fn flush(&mut self) -> Result<()> {
            self.bytes.flush()
        }
    }

    #[test]
    fn test_object_empty() {
        let mut bb = MyBuf { bytes: vec![] };
        let bw = Box::new(&mut bb);
        {
            // let mut ser = JsonXsSerializer::use_stdout();
            let mut ser = JsonXsSerializer { writer: bw, levels: Default::default() };
            ser.open_obj(JsonXsValue::NA).unwrap();
            ser.close().unwrap();
            ser.done().unwrap();
        }
        //todo check output
        println!("TEST OK: {}", bb.collected_output());
    }

    #[test]
    fn test_array_empty() {
        let mut ser = JsonXsSerializer::use_stdout();
        ser.open_array(JsonXsValue::NA).unwrap();
        ser.close().unwrap();
        ser.done().unwrap();
        println!("TEST OK");
    }
}
